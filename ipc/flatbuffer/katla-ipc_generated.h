// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_KATLAIPC_KATLA_IPC_FB_H_
#define FLATBUFFERS_GENERATED_KATLAIPC_KATLA_IPC_FB_H_

#include "flatbuffers/flatbuffers.h"

namespace katla {
namespace ipc {
namespace fb {

struct Message;

struct Notification;

struct NotificationAck;

struct Request;

struct RequestResponse;

enum class MessageType : int16_t {
  InvalidMessageType = 0,
  NotificationMessageType = 1,
  NotificationAckMessageType = 2,
  RequestMessageType = 3,
  RequestResponseMessageType = 4,
  MIN = InvalidMessageType,
  MAX = RequestResponseMessageType
};

inline const MessageType (&EnumValuesMessageType())[5] {
  static const MessageType values[] = {
    MessageType::InvalidMessageType,
    MessageType::NotificationMessageType,
    MessageType::NotificationAckMessageType,
    MessageType::RequestMessageType,
    MessageType::RequestResponseMessageType
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "InvalidMessageType",
    "NotificationMessageType",
    "NotificationAckMessageType",
    "RequestMessageType",
    "RequestResponseMessageType",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (e < MessageType::InvalidMessageType || e > MessageType::RequestResponseMessageType) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum class NotificationType : int16_t {
  InvalidNotificationType = 0,
  HeartBeatNotificationType = 1,
  EventNotificationType = 2,
  MIN = InvalidNotificationType,
  MAX = EventNotificationType
};

inline const NotificationType (&EnumValuesNotificationType())[3] {
  static const NotificationType values[] = {
    NotificationType::InvalidNotificationType,
    NotificationType::HeartBeatNotificationType,
    NotificationType::EventNotificationType
  };
  return values;
}

inline const char * const *EnumNamesNotificationType() {
  static const char * const names[] = {
    "InvalidNotificationType",
    "HeartBeatNotificationType",
    "EventNotificationType",
    nullptr
  };
  return names;
}

inline const char *EnumNameNotificationType(NotificationType e) {
  if (e < NotificationType::InvalidNotificationType || e > NotificationType::EventNotificationType) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNotificationType()[index];
}

enum class NotificationAckType : int16_t {
  InvalidNotificationAckType = 0,
  EventNotificationAckType = 1,
  MIN = InvalidNotificationAckType,
  MAX = EventNotificationAckType
};

inline const NotificationAckType (&EnumValuesNotificationAckType())[2] {
  static const NotificationAckType values[] = {
    NotificationAckType::InvalidNotificationAckType,
    NotificationAckType::EventNotificationAckType
  };
  return values;
}

inline const char * const *EnumNamesNotificationAckType() {
  static const char * const names[] = {
    "InvalidNotificationAckType",
    "EventNotificationAckType",
    nullptr
  };
  return names;
}

inline const char *EnumNameNotificationAckType(NotificationAckType e) {
  if (e < NotificationAckType::InvalidNotificationAckType || e > NotificationAckType::EventNotificationAckType) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNotificationAckType()[index];
}

enum class RequestType : int16_t {
  InvalidRequestType = 0,
  QueryRequestType = 1,
  CommandRequestType = 2,
  MIN = InvalidRequestType,
  MAX = CommandRequestType
};

inline const RequestType (&EnumValuesRequestType())[3] {
  static const RequestType values[] = {
    RequestType::InvalidRequestType,
    RequestType::QueryRequestType,
    RequestType::CommandRequestType
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[] = {
    "InvalidRequestType",
    "QueryRequestType",
    "CommandRequestType",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (e < RequestType::InvalidRequestType || e > RequestType::CommandRequestType) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum class RequestResponseType : int16_t {
  InvalidRequestResponseType = 0,
  QueryRequestResponseType = 1,
  CommandRequestResponseType = 2,
  MIN = InvalidRequestResponseType,
  MAX = CommandRequestResponseType
};

inline const RequestResponseType (&EnumValuesRequestResponseType())[3] {
  static const RequestResponseType values[] = {
    RequestResponseType::InvalidRequestResponseType,
    RequestResponseType::QueryRequestResponseType,
    RequestResponseType::CommandRequestResponseType
  };
  return values;
}

inline const char * const *EnumNamesRequestResponseType() {
  static const char * const names[] = {
    "InvalidRequestResponseType",
    "QueryRequestResponseType",
    "CommandRequestResponseType",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestResponseType(RequestResponseType e) {
  if (e < RequestResponseType::InvalidRequestResponseType || e > RequestResponseType::CommandRequestResponseType) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestResponseType()[index];
}

enum class WireFormat : int16_t {
  FlatBuffer = 0,
  Json = 1,
  MIN = FlatBuffer,
  MAX = Json
};

inline const WireFormat (&EnumValuesWireFormat())[2] {
  static const WireFormat values[] = {
    WireFormat::FlatBuffer,
    WireFormat::Json
  };
  return values;
}

inline const char * const *EnumNamesWireFormat() {
  static const char * const names[] = {
    "FlatBuffer",
    "Json",
    nullptr
  };
  return names;
}

inline const char *EnumNameWireFormat(WireFormat e) {
  if (e < WireFormat::FlatBuffer || e > WireFormat::Json) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWireFormat()[index];
}

enum class MessageBody : uint8_t {
  NONE = 0,
  Notification = 1,
  NotificationAck = 2,
  Request = 3,
  RequestResponse = 4,
  MIN = NONE,
  MAX = RequestResponse
};

inline const MessageBody (&EnumValuesMessageBody())[5] {
  static const MessageBody values[] = {
    MessageBody::NONE,
    MessageBody::Notification,
    MessageBody::NotificationAck,
    MessageBody::Request,
    MessageBody::RequestResponse
  };
  return values;
}

inline const char * const *EnumNamesMessageBody() {
  static const char * const names[] = {
    "NONE",
    "Notification",
    "NotificationAck",
    "Request",
    "RequestResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageBody(MessageBody e) {
  if (e < MessageBody::NONE || e > MessageBody::RequestResponse) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageBody()[index];
}

template<typename T> struct MessageBodyTraits {
  static const MessageBody enum_value = MessageBody::NONE;
};

template<> struct MessageBodyTraits<Notification> {
  static const MessageBody enum_value = MessageBody::Notification;
};

template<> struct MessageBodyTraits<NotificationAck> {
  static const MessageBody enum_value = MessageBody::NotificationAck;
};

template<> struct MessageBodyTraits<Request> {
  static const MessageBody enum_value = MessageBody::Request;
};

template<> struct MessageBodyTraits<RequestResponse> {
  static const MessageBody enum_value = MessageBody::RequestResponse;
};

bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type);
bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DESTINATION = 6,
    VT_DISPATCHER_ID = 8,
    VT_MESSAGE_TYPE = 10,
    VT_MESSAGE = 12
  };
  int32_t source() const {
    return GetField<int32_t>(VT_SOURCE, 0);
  }
  int32_t destination() const {
    return GetField<int32_t>(VT_DESTINATION, 0);
  }
  int32_t dispatcher_id() const {
    return GetField<int32_t>(VT_DISPATCHER_ID, 0);
  }
  MessageBody message_type() const {
    return static_cast<MessageBody>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const Notification *message_as_Notification() const {
    return message_type() == MessageBody::Notification ? static_cast<const Notification *>(message()) : nullptr;
  }
  const NotificationAck *message_as_NotificationAck() const {
    return message_type() == MessageBody::NotificationAck ? static_cast<const NotificationAck *>(message()) : nullptr;
  }
  const Request *message_as_Request() const {
    return message_type() == MessageBody::Request ? static_cast<const Request *>(message()) : nullptr;
  }
  const RequestResponse *message_as_RequestResponse() const {
    return message_type() == MessageBody::RequestResponse ? static_cast<const RequestResponse *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SOURCE) &&
           VerifyField<int32_t>(verifier, VT_DESTINATION) &&
           VerifyField<int32_t>(verifier, VT_DISPATCHER_ID) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessageBody(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Notification *Message::message_as<Notification>() const {
  return message_as_Notification();
}

template<> inline const NotificationAck *Message::message_as<NotificationAck>() const {
  return message_as_NotificationAck();
}

template<> inline const Request *Message::message_as<Request>() const {
  return message_as_Request();
}

template<> inline const RequestResponse *Message::message_as<RequestResponse>() const {
  return message_as_RequestResponse();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source(int32_t source) {
    fbb_.AddElement<int32_t>(Message::VT_SOURCE, source, 0);
  }
  void add_destination(int32_t destination) {
    fbb_.AddElement<int32_t>(Message::VT_DESTINATION, destination, 0);
  }
  void add_dispatcher_id(int32_t dispatcher_id) {
    fbb_.AddElement<int32_t>(Message::VT_DISPATCHER_ID, dispatcher_id, 0);
  }
  void add_message_type(MessageBody message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t source = 0,
    int32_t destination = 0,
    int32_t dispatcher_id = 0,
    MessageBody message_type = MessageBody::NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_dispatcher_id(dispatcher_id);
  builder_.add_destination(destination);
  builder_.add_source(source);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Notification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_BYTES = 6
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           verifier.EndTable();
  }
};

struct NotificationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Notification::VT_ID, id, 0);
  }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(Notification::VT_BYTES, bytes);
  }
  explicit NotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotificationBuilder &operator=(const NotificationBuilder &);
  flatbuffers::Offset<Notification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Notification>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notification> CreateNotification(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  NotificationBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notification> CreateNotificationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const std::vector<uint8_t> *bytes = nullptr) {
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  return katla::ipc::fb::CreateNotification(
      _fbb,
      id,
      bytes__);
}

struct NotificationAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct NotificationAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(NotificationAck::VT_ID, id, 0);
  }
  explicit NotificationAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotificationAckBuilder &operator=(const NotificationAckBuilder &);
  flatbuffers::Offset<NotificationAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotificationAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotificationAck> CreateNotificationAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0) {
  NotificationAckBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FORMAT = 6,
    VT_BODY = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int16_t format() const {
    return GetField<int16_t>(VT_FORMAT, 0);
  }
  const flatbuffers::Vector<uint8_t> *body() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.VerifyVector(body()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Request::VT_ID, id, 0);
  }
  void add_format(int16_t format) {
    fbb_.AddElement<int16_t>(Request::VT_FORMAT, format, 0);
  }
  void add_body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body) {
    fbb_.AddOffset(Request::VT_BODY, body);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t format = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_id(id);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t format = 0,
    const std::vector<uint8_t> *body = nullptr) {
  auto body__ = body ? _fbb.CreateVector<uint8_t>(*body) : 0;
  return katla::ipc::fb::CreateRequest(
      _fbb,
      id,
      format,
      body__);
}

struct RequestResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FORMAT = 6,
    VT_BODY = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int16_t format() const {
    return GetField<int16_t>(VT_FORMAT, 0);
  }
  const flatbuffers::Vector<uint8_t> *body() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.VerifyVector(body()) &&
           verifier.EndTable();
  }
};

struct RequestResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(RequestResponse::VT_ID, id, 0);
  }
  void add_format(int16_t format) {
    fbb_.AddElement<int16_t>(RequestResponse::VT_FORMAT, format, 0);
  }
  void add_body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body) {
    fbb_.AddOffset(RequestResponse::VT_BODY, body);
  }
  explicit RequestResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestResponseBuilder &operator=(const RequestResponseBuilder &);
  flatbuffers::Offset<RequestResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestResponse> CreateRequestResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t format = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body = 0) {
  RequestResponseBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_id(id);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestResponse> CreateRequestResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t format = 0,
    const std::vector<uint8_t> *body = nullptr) {
  auto body__ = body ? _fbb.CreateVector<uint8_t>(*body) : 0;
  return katla::ipc::fb::CreateRequestResponse(
      _fbb,
      id,
      format,
      body__);
}

inline bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type) {
  switch (type) {
    case MessageBody::NONE: {
      return true;
    }
    case MessageBody::Notification: {
      auto ptr = reinterpret_cast<const Notification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::NotificationAck: {
      auto ptr = reinterpret_cast<const NotificationAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::Request: {
      auto ptr = reinterpret_cast<const Request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::RequestResponse: {
      auto ptr = reinterpret_cast<const RequestResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageBody(
        verifier,  values->Get(i), types->GetEnum<MessageBody>(i))) {
      return false;
    }
  }
  return true;
}

inline const katla::ipc::fb::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<katla::ipc::fb::Message>(buf);
}

inline const katla::ipc::fb::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<katla::ipc::fb::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<katla::ipc::fb::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<katla::ipc::fb::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<katla::ipc::fb::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<katla::ipc::fb::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fb
}  // namespace ipc
}  // namespace katla

#endif  // FLATBUFFERS_GENERATED_KATLAIPC_KATLA_IPC_FB_H_
